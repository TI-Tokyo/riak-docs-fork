---
title: "Re: Java Riak client can't handle a Riak node failure?"
description: ""
project: community
lastmod: 2016-02-22T10:27:12-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg17054"
mailinglist_parent_id: "msg16628"
author_name: "Vanessa Williams"
project_section: "mailinglistitem"
sent_date: 2016-02-22T10:27:12-08:00
---


Hi Alex, would a second fetch just indicate that the object is \\*still\\*
deleted? Or that this delete operation succeeded? In other words, perhaps
what my contract really is is: return true if there was already a value
there. In which case would the second fetch be superfluous?

Thanks for your help.

Vanessa

On Mon, Feb 22, 2016 at 11:15 AM, Alex Moore  wrote:

&gt; That's the correct behaviour: it should return true iff a value was
&gt;&gt; actually deleted.
&gt;
&gt;
&gt; Ok, if that's the case you should do another FetchValue after the deletion
&gt; (to update the response.hasValues()) field, or use the async version of
&gt; the delete function. I also noticed that we weren't passing the vclock to
&gt; the Delete function, so I added that here as well:
&gt;
&gt; public boolean delete(String key) throws ExecutionException, 
&gt; InterruptedException {
&gt;
&gt; // fetch in order to get the causal context
&gt; FetchValue.Response response = fetchValue(key);
&gt;
&gt; if(response.isNotFound())
&gt; {
&gt; return ???; // what do we return if it doesn't exist?
&gt; }
&gt;
&gt; DeleteValue deleteValue = new DeleteValue.Builder(new Location(namespace, 
&gt; key))
&gt; 
&gt; .withVClock(response.getVectorClock())
&gt; .build();
&gt;
&gt; final RiakFuture deleteFuture = 
&gt; client.executeAsync(deleteValue);
&gt;
&gt; deleteFuture.await();
&gt;
&gt; if(deleteFuture.isSuccess())
&gt; {
&gt; return true;
&gt; }
&gt; else
&gt; {
&gt; deleteFuture.cause(); // Cause of failure
&gt; return false;
&gt; }
&gt; }
&gt;
&gt;
&gt; Thanks,
&gt; Alex
&gt;
&gt; On Mon, Feb 22, 2016 at 10:48 AM, Vanessa Williams &lt;
&gt; vanessa.willi...@thoughtwire.ca&gt; wrote:
&gt;
&gt;&gt; See inline:
&gt;&gt;
&gt;&gt; On Mon, Feb 22, 2016 at 10:31 AM, Alex Moore  wrote:
&gt;&gt;
&gt;&gt;&gt; Hi Vanessa,
&gt;&gt;&gt;
&gt;&gt;&gt; You might have a problem with your delete function (depending on it's
&gt;&gt;&gt; return value).
&gt;&gt;&gt; What does the return value of the delete() function indicate? Right now
&gt;&gt;&gt; if an object existed, and was deleted, the function will return true, and
&gt;&gt;&gt; will only return false if the object didn't exist or only consisted of
&gt;&gt;&gt; tombstones.
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; That's the correct behaviour: it should return true iff a value was
&gt;&gt; actually deleted.
&gt;&gt;
&gt;&gt;
&gt;&gt;&gt; If you never look at the object value returned by your fetchValue(key) 
&gt;&gt;&gt; function, another potential optimization you could make is to only return 
&gt;&gt;&gt; the HEAD / metadata:
&gt;&gt;&gt;
&gt;&gt;&gt; FetchValue fv = new FetchValue.Builder(new Location(new Namespace(
&gt;&gt;&gt; "some\\_bucket"), key))
&gt;&gt;&gt;
&gt;&gt;&gt; .withOption(FetchValue.Option.HEAD, true)
&gt;&gt;&gt; .build();
&gt;&gt;&gt;
&gt;&gt;&gt; This would be more efficient because Riak won't have to send you the
&gt;&gt;&gt; values over the wire, if you only need the metadata.
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt; Thanks, I'll clean that up.
&gt;&gt;
&gt;&gt;
&gt;&gt;&gt; If you do write this up somewhere, share the link! :)
&gt;&gt;&gt;
&gt;&gt;
&gt;&gt; Will do!
&gt;&gt;
&gt;&gt; Regards,
&gt;&gt; Vanessa
&gt;&gt;
&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; Thanks,
&gt;&gt;&gt; Alex
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; On Mon, Feb 22, 2016 at 6:23 AM, Vanessa Williams &lt;
&gt;&gt;&gt; vanessa.willi...@thoughtwire.ca&gt; wrote:
&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Hi Dmitri, this thread is old, but I read this part of your answer
&gt;&gt;&gt;&gt; carefully:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; You can use the following strategies to prevent stale values, in
&gt;&gt;&gt;&gt;&gt; increasing order of security/preference:
&gt;&gt;&gt;&gt;&gt; 1) Use timestamps (and not pass in vector clocks/causal context). This
&gt;&gt;&gt;&gt;&gt; is ok if you're not editing objects, or you're ok with a bit of risk of
&gt;&gt;&gt;&gt;&gt; stale values.
&gt;&gt;&gt;&gt;&gt; 2) Use causal context correctly (which means, read-before-you-write --
&gt;&gt;&gt;&gt;&gt; in fact, the Update operation in the java client does this for you, I
&gt;&gt;&gt;&gt;&gt; think). And if Riak can't determine which version is correct, it will fall
&gt;&gt;&gt;&gt;&gt; back on timestamps.
&gt;&gt;&gt;&gt;&gt; 3) Turn on siblings, for that bucket or bucket type. That way, Riak
&gt;&gt;&gt;&gt;&gt; will still try to use causal context to decide the right value. But if it
&gt;&gt;&gt;&gt;&gt; can't decide, it will store BOTH values, and give them back to you on the
&gt;&gt;&gt;&gt;&gt; next read, so that your application can decide which is the correct one.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; I decided on strategy #2. What I am hoping for is some validation that
&gt;&gt;&gt;&gt; the code we use to "get", "put", and "delete" is correct in that context,
&gt;&gt;&gt;&gt; or if it could be simplified in some cases. Not we are using delete-mode
&gt;&gt;&gt;&gt; "immediate" and no duplicates.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; In their shortest possible forms, here are the three methods I'd like
&gt;&gt;&gt;&gt; some feedback on (note, they're being used in production and haven't caused
&gt;&gt;&gt;&gt; any problems yet, however we have very few writes in production so the lack
&gt;&gt;&gt;&gt; of problems doesn't support the conclusion that the implementation is
&gt;&gt;&gt;&gt; correct.) Note all argument-checking, exception-handling, and logging
&gt;&gt;&gt;&gt; removed for clarity. \\*I'm mostly concerned about correct use of causal
&gt;&gt;&gt;&gt; context and response.isNotFound and response.hasValues. \\*Is there
&gt;&gt;&gt;&gt; anything I could/should have left out?
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; public RiakClient(String name,
&gt;&gt;&gt;&gt; com.basho.riak.client.api.RiakClient client)
&gt;&gt;&gt;&gt; {
&gt;&gt;&gt;&gt; this.name = name;
&gt;&gt;&gt;&gt; this.namespace = new Namespace(name);
&gt;&gt;&gt;&gt; this.client = client;
&gt;&gt;&gt;&gt; }
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; public byte[] get(String key) throws ExecutionException,
&gt;&gt;&gt;&gt; InterruptedException {
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; FetchValue.Response response = fetchValue(key);
&gt;&gt;&gt;&gt; if (!response.isNotFound())
&gt;&gt;&gt;&gt; {
&gt;&gt;&gt;&gt; RiakObject riakObject = response.getValue(RiakObject.class);
&gt;&gt;&gt;&gt; return riakObject.getValue().getValue();
&gt;&gt;&gt;&gt; }
&gt;&gt;&gt;&gt; return null;
&gt;&gt;&gt;&gt; }
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; public void put(String key, byte[] value) throws
&gt;&gt;&gt;&gt; ExecutionException, InterruptedException {
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; // fetch in order to get the causal context
&gt;&gt;&gt;&gt; FetchValue.Response response = fetchValue(key);
&gt;&gt;&gt;&gt; RiakObject storeObject = new
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; RiakObject().setValue(BinaryValue.create(value)).setContentType("binary/octet-stream");
&gt;&gt;&gt;&gt; StoreValue.Builder builder =
&gt;&gt;&gt;&gt; new StoreValue.Builder(storeObject).withLocation(new
&gt;&gt;&gt;&gt; Location(namespace, key));
&gt;&gt;&gt;&gt; if (response.getVectorClock() != null) {
&gt;&gt;&gt;&gt; builder =
&gt;&gt;&gt;&gt; builder.withVectorClock(response.getVectorClock());
&gt;&gt;&gt;&gt; }
&gt;&gt;&gt;&gt; StoreValue storeValue = builder.build();
&gt;&gt;&gt;&gt; client.execute(storeValue);
&gt;&gt;&gt;&gt; }
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; public boolean delete(String key) throws ExecutionException,
&gt;&gt;&gt;&gt; InterruptedException {
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; // fetch in order to get the causal context
&gt;&gt;&gt;&gt; FetchValue.Response response = fetchValue(key);
&gt;&gt;&gt;&gt; if (!response.isNotFound())
&gt;&gt;&gt;&gt; {
&gt;&gt;&gt;&gt; DeleteValue deleteValue = new DeleteValue.Builder(new
&gt;&gt;&gt;&gt; Location(namespace, key)).build();
&gt;&gt;&gt;&gt; client.execute(deleteValue);
&gt;&gt;&gt;&gt; }
&gt;&gt;&gt;&gt; return !response.isNotFound() || !response.hasValues();
&gt;&gt;&gt;&gt; }
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Any comments much appreciated. I want to provide a minimally correct
&gt;&gt;&gt;&gt; example of simple client code somewhere (GitHub, blog post, something...)
&gt;&gt;&gt;&gt; so I don't want to post this without review.
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; Thanks,
&gt;&gt;&gt;&gt; Vanessa
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; ThoughtWire Corporation
&gt;&gt;&gt;&gt; http://www.thoughtwire.com
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; On Thu, Oct 8, 2015 at 8:45 AM, Dmitri Zagidulin 
&gt;&gt;&gt;&gt; wrote:
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Hi Vanessa,
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; The thing to keep in mind about read repair is -- it happens
&gt;&gt;&gt;&gt;&gt; asynchronously on every GET, but /after/ the results are returned to the
&gt;&gt;&gt;&gt;&gt; client.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; So, when you issue a GET with r=1, the coordinating node only waits
&gt;&gt;&gt;&gt;&gt; for 1 of the replicas before responding to the client with a success, and
&gt;&gt;&gt;&gt;&gt; only afterwards triggers read-repair.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; It's true that with notfound\\_ok=false, it'll wait for the first
&gt;&gt;&gt;&gt;&gt; non-missing replica before responding. But if you edit or update your
&gt;&gt;&gt;&gt;&gt; objects at all, an R=1 still gives you a risk of stale values being
&gt;&gt;&gt;&gt;&gt; returned.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; For example, say you write an object with value A. And let's say your
&gt;&gt;&gt;&gt;&gt; 3 replicas now look like this:
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; replica 1: A, replica 2: A, replica 3: notfound/missing
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; A read with an R=1 and notfound\\_ok=false is just fine, here. (Chances
&gt;&gt;&gt;&gt;&gt; are, the notfound replica will arrive first, but the notfound\\_ok setting
&gt;&gt;&gt;&gt;&gt; will force the coordinator to wait for the first non-empty value, A, and
&gt;&gt;&gt;&gt;&gt; return it to the client. And then trigger read-repair).
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; But what happens if you edit that same object, and give it a new
&gt;&gt;&gt;&gt;&gt; value, B? So, now, there's a chance that your replicas will look like 
&gt;&gt;&gt;&gt;&gt; this:
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; replica 1: A, replica 2: B, replica 3: B.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; So now if you do a read with an R=1, there's a chance that replica 1,
&gt;&gt;&gt;&gt;&gt; with the old value of A, will arrive first, and that's the response that
&gt;&gt;&gt;&gt;&gt; will be returned to the client.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; Whereas, using R=2 eliminates that risk -- well, at least decreases
&gt;&gt;&gt;&gt;&gt; it. You still have the issue of -- how does Riak decide whether A or B is
&gt;&gt;&gt;&gt;&gt; the correct value? Are you using causal context/vclocks correctly? (That
&gt;&gt;&gt;&gt;&gt; is, reading the object before you update, to get the correct causal
&gt;&gt;&gt;&gt;&gt; context?) Or are you relying on timestamps? (This is an ok strategy,
&gt;&gt;&gt;&gt;&gt; provided that the edits are sufficiently far apart in time, and you don't
&gt;&gt;&gt;&gt;&gt; have many concurrent edits, AND you're ok with the small risk of
&gt;&gt;&gt;&gt;&gt; occasionally the timestamp being wrong). You can use the following
&gt;&gt;&gt;&gt;&gt; strategies to prevent stale values, in increasing order of
&gt;&gt;&gt;&gt;&gt; security/preference:
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; 1) Use timestamps (and not pass in vector clocks/causal context). This
&gt;&gt;&gt;&gt;&gt; is ok if you're not editing objects, or you're ok with a bit of risk of
&gt;&gt;&gt;&gt;&gt; stale values.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; 2) Use causal context correctly (which means, read-before-you-write --
&gt;&gt;&gt;&gt;&gt; in fact, the Update operation in the java client does this for you, I
&gt;&gt;&gt;&gt;&gt; think). And if Riak can't determine which version is correct, it will fall
&gt;&gt;&gt;&gt;&gt; back on timestamps.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; 3) Turn on siblings, for that bucket or bucket type. That way, Riak
&gt;&gt;&gt;&gt;&gt; will still try to use causal context to decide the right value. But if it
&gt;&gt;&gt;&gt;&gt; can't decide, it will store BOTH values, and give them back to you on the
&gt;&gt;&gt;&gt;&gt; next read, so that your application can decide which is the correct one.
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt; On Thu, Oct 8, 2015 at 1:56 AM, Vanessa Williams &lt;
&gt;&gt;&gt;&gt;&gt; vanessa.willi...@thoughtwire.ca&gt; wrote:
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; Hi Dmitri, what would be the benefit of r=2, exactly? It isn't
&gt;&gt;&gt;&gt;&gt;&gt; necessary to trigger read-repair, is it? If it's important I'd rather try
&gt;&gt;&gt;&gt;&gt;&gt; it sooner than later...
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; Regards,
&gt;&gt;&gt;&gt;&gt;&gt; Vanessa
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Oct 7, 2015 at 4:02 PM, Dmitri Zagidulin &lt;
&gt;&gt;&gt;&gt;&gt;&gt; dzagidu...@basho.com&gt; wrote:
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; Glad you sorted it out!
&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; (I do want to encourage you to bump your R setting to at least 2,
&gt;&gt;&gt;&gt;&gt;&gt;&gt; though. Run some tests -- I think you'll find that the difference in 
&gt;&gt;&gt;&gt;&gt;&gt;&gt; speed
&gt;&gt;&gt;&gt;&gt;&gt;&gt; will not be noticeable, but you do get a lot more data resilience with 
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2.)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Oct 7, 2015 at 6:24 PM, Vanessa Williams &lt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; vanessa.willi...@thoughtwire.ca&gt; wrote:
&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Dmitri, well...we solved our problem to our satisfaction but it
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; turned out to be something unexpected.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The keys were two properties mentioned in a blog post on
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; "configuring Riakâ€™s oft-subtle behavioral characteristics":
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; http://basho.com/posts/technical/riaks-config-behaviors-part-4/
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; notfound\\_ok= false
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; basic\\_quorum=true
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The 2nd one just makes things a little faster, but the first one is
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the one whose default value of true was killing us.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With r=1 and notfound\\_ok=true (default) the first node to respond,
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if it didn't find the requested key, the authoritative answer was 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; "this key
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is not found". Not what we were expecting at all.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the changed settings, it will wait for a quorum of responses
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and only if \\*no one\\* finds the key will "not found" be returned. 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Perfect.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (Without this setting it would wait for all responses, not ideal.)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Now there is only one snag, which is that if the Riak node the
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; client connects to goes down, there will be no communication and we 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; have a
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; problem. This is easily solvable with a load-balancer, though for
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; complicated reasons we actually don't need to do that right now. It's 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; just
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; acceptable for us temporarily. Later, we'll get the load-balancer 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; working
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and even that won't be a problem.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I \\*think\\* we're ok now. Thanks for your help!
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Regards,
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Vanessa
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Oct 7, 2015 at 9:33 AM, Dmitri Zagidulin &lt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dzagidu...@basho.com&gt; wrote:
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yeah, definitely find out what the sysadmin's experience was, with
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the load balancer. It could have just been a wrong configuration or
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; And yes, that's the documentation page I recommend -
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; http://docs.basho.com/riak/latest/ops/advanced/configs/load-balancing-proxy/
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Just set up HAProxy, and point your Java clients to its IP.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The drawbacks to load-balancing on the java client side (yes, the
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; cluster object) instead of a standalone load balancer like HAProxy, 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; are the
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; following:
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1) Adding node means code changes (or at very least, config file
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; changes) rolled out to all your clients. Which turns out to be a 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; pretty
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; serious hassle. Instead, HAProxy allows you to add or remove nodes 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; without
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; changing any java code or config files.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2) Performance. We've ran many tests to compare performance, and
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; client-side load balancing results in significantly lower throughput 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; than
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you'd have using haproxy (or nginx). (Specifically, you actually want 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; use the 'leastconn' load balancing algorithm with HAProxy, instead of 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; round
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; robin).
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3) The health check on the client side (so that the java load
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; balancer can tell when a remote node is down) is much less 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; intelligent than
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a dedicated load balancer would provide. With something like HAProxy, 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be able to take down nodes with no ill effects for the client 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; code.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Now, if you load balance on the client side and you take a node
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; down, it's not supposed to stop working completely. (I'm not sure why 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it's
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; failing for you, we can investigate, but it'll be easier to just use 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a load
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; balancer). It should throw an error or two, but then start working 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; again
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (on the retry).
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Dmitri
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Oct 7, 2015 at 2:45 PM, Vanessa Williams &lt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; vanessa.willi...@thoughtwire.ca&gt; wrote:
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Dmitri, thanks for the quick reply.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It was actually our sysadmin who tried the load balancer approach
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and had no success, late last evening. However I haven't discussed 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the gory
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; details with him yet. The failure he saw was at the application 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; level (i.e.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; failure to read a key), but I don't know a) how he set up the LB or 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; b) what
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the Java exception was, if any. I'll find that out in an hour or two 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; report back.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I did find this article just now:
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; http://docs.basho.com/riak/latest/ops/advanced/configs/load-balancing-proxy/
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So I suppose we'll give those suggestions a try this morning.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What is the drawback to having the client connect to all 4 nodes
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (the cluster client, I assume you mean?) My understanding from 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reading
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; articles I've found is that one of the nodes going away causes that 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; client
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to fail as well. Is that what you mean, or are there other drawbacks 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; as
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; well?
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If there's anything else you can recommend, or links other than
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the one above you can point me to, it would be much appreciated. We 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; expect
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; both node failure and deliberate node removal for upgrade, repair,
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replacement, etc.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Regards,
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Vanessa
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Oct 7, 2015 at 8:29 AM, Dmitri Zagidulin &lt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dzagidu...@basho.com&gt; wrote:
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Vanessa,
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Riak is definitely meant to run behind a load balancer. (Or, at
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the worst case, to be load-balanced on the client side. That is, all
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; clients connect to all 4 nodes).
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When you say "we did try putting all 4 Riak nodes behind a
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; load-balancer and pointing the clients at it, but it didn't help." 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- what
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; do you mean exactly, by "it didn't help"? What happened when you 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; tried
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; using the load balancer?
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Oct 7, 2015 at 1:57 PM, Vanessa Williams &lt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; vanessa.willi...@thoughtwire.ca&gt; wrote:
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi all, we are still (for a while longer) using Riak 1.4 and
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the matching Java client. The client(s) connect to one node in the 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; cluster
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (since that's all it can do in this client version). The cluster 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; itself has
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4 nodes (sorry, we can't use 5 in this scenario). There are 2 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; separate
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; clients.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We've tried both n\\_val = 3 and n\\_val=4. We achieve
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; consistency-by-writes by setting w=all. Therefore, we only require 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; one
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; successful read (r=1).
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When all nodes are up, everything is fine. If one node fails,
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the clients can no longer read any keys at all. There's an 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; exception like
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this:
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; com.basho.riak.client.RiakRetryFailedException:
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; java.net.ConnectException: Connection refused
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Now, it isn't possible that Riak can't operate when one node
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fails, so we're clearly missing something here.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note: we did try putting all 4 Riak nodes behind a
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; load-balancer and pointing the clients at it, but it didn't help.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Riak is a high-availability key-value store, so... why are we
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; failing to achieve high-availability? Any suggestions greatly 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; appreciated,
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; and if more info is required I'll do my best to provide it.
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks in advance,
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Vanessa
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; --
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Vanessa Williams
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ThoughtWire Corporation
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; http://www.thoughtwire.com
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt; \\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
&gt;&gt;&gt;&gt; riak-users mailing list
&gt;&gt;&gt;&gt; riak-users@lists.basho.com
&gt;&gt;&gt;&gt; http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;
&gt;
\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_\\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\\_lists.basho.com

