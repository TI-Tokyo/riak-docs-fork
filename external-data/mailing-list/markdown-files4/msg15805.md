---
title: "Re: Java Client update vs store"
description: ""
project: community
lastmod: 2015-02-27T10:46:52-08:00
sitemap:
  priority: 0.2
layout: mailinglistitem
mailinglist_id: "msg15805"
mailinglist_parent_id: "msg15629"
author_name: "Brian Roach"
project_section: "mailinglistitem"
sent_date: 2015-02-27T10:46:52-08:00
---


This was due to the UpdateValueFuture not checking for the exception
when the get() methods were called. Just fixed this, it'll be in the
very-soon-to-be-cut 2.0.1 release.

https://github.com/basho/riak-java-client/pull/503

Sync calls are just a wrapper around the async call that calls get() -
You can currently work around this by calling UpdateValue async:

RiakFuture future =
Riakclient.executeAsync(updateOp);

future.await();
if (future.isSuccess()) {
 ...
} else {
 ...
}

Thanks,
- Roach

On Tue, Feb 3, 2015 at 3:39 PM, Cosmin Marginean  wrote:
&gt; I have an edge case where consistency is favoured over availability so I’m
&gt; using a "consistent": true bucket type for a very specific operation.
&gt; I worked in testing my setup so ended up faking an entire failure by
&gt; deliberately using an incorrect vClock.
&gt;
&gt; Using StoreValue, the (second) write fails as expected
&gt;
&gt; FetchValue fetchOp = new FetchValue.Builder(location(id)).build();
&gt; VClock vClock = client.execute(fetchOp).getVectorClock();
&gt; //fiddle with vClock or allow the first write to finish before the next
&gt; step
&gt; StoreValue storeOp = new StoreValue.Builder(value)
&gt; .withVectorClock(vClock)
&gt; .withLocation(location(id)).build();
&gt; StoreValue.Response response = client.execute(storeOp);
&gt;
&gt;
&gt; Caused by: com.basho.riak.client.core.netty.RiakResponseException: failed
&gt; at
&gt; com.basho.riak.client.core.netty.RiakResponseHandler.channelRead(RiakResponseHandler.java:52)
&gt; at
&gt; io.netty.channel.DefaultChannelHandlerContext.invokeChannelRead(DefaultChannelHandlerContext.java:340)
&gt; at
&gt; io.netty.channel.DefaultChannelHandlerContext.fireChannelRead(DefaultChannelHandlerContext.java:326)
&gt;
&gt;
&gt; I managed to override the UpdateValue class to simulate a similar failure
&gt; scenario (so I don’t have to do the fetch + store myself). I was expecting a
&gt; similar result, however, after some analysis I realised that an exception is
&gt; being swallowed somewhere.
&gt; I believe the trouble might be around this area:
&gt; https://github.com/basho/riak-java-client/blob/develop/src/main/java/com/basho/riak/client/api/commands/kv/UpdateValue.java#L581
&gt;
&gt; The exception is not allowed to bubble up to the client code. Additionally,
&gt; another net effect of this seems to be that a null response is returned here
&gt;
&gt; UpdateValue.Response res = client.execute(updateOp);
&gt;
&gt; So a call to res.wasUpdated() will produce a NPE!
&gt;
&gt; The way I see it, this code needs to either
&gt; 1) return not-null res and res.wasUpdated() as false
&gt; or
&gt; 2) allow the exception to bubble up
&gt;
&gt; Please let me know your thoughts
&gt;
&gt; Thank you
&gt; Cos
&gt;
&gt;
&gt; \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
&gt; riak-users mailing list
&gt; riak-users@lists.basho.com
&gt; http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com
&gt;

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
riak-users mailing list
riak-users@lists.basho.com
http://lists.basho.com/mailman/listinfo/riak-users\_lists.basho.com

